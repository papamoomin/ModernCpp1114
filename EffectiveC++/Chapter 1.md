[뒤로](https://github.com/papamoomin/Study#a-tour-of-c)  

# 목차
[1. C++은 언어들의 연합체이다.](#Item1)  
[2. #define보다는 const, enum, inline.](#Item2)

<br><br><br>

# Chapter 1. C++에 왔으면 C++의 법을 따라라

<a name="Item1"></a>
## 1. C++은 언어들의 연합체이다.

C++은 <b>다중패러다임 프로그래밍 언어(multiparadigm programming language)</b>이다. 절차적(procedural) 프로그래밍을 베이스로, 객체 지향(objectoriented), 함수식(functional), 일반화(generic), 메타프로그래밍(metaprogramming) 개념까지 지원한다.

그러므로 c++은 단일 언어라기보다 여러 언어들의 연합체로 보는 것이 좋다. 

### c++의 하위 언어
- <b>C</b> : c++은 c를 기본으로 한다. c에서 블록, 문장, 선행 처리자, 기본제공 데이터타입, 배열, 포인터 등의 많은 것을 가지고 왔다.

- <b>객체 지향 개념 C++</b> : 클래스를 사용하는 C에 관한 모든 것. 클래스, 캡슐화, 상속, 다형성, 가상 함수(동적 바인딩) 등이다.

- <b>템플릿 C++</b> : C++의 일반화 프로그래밍 부분. 오늘날 이 템플릿이 C++에 끼치는 영향은 전방위적이기 때문에 <b>템플릿 메타프로그래밍(template metaprogramming : TMP)</b>이라는 프로그래밍 패러다임이 파생되었다. 

- <b>STL</b> : STL은 Standard Template Library로, 컨테이너와 반복자, 알고리즘과 함수 객체들이 엮여 돌아간다.

C++은 이 하위 언어들로 구성되어 있다. 그리고 C++을 사용한 효과적인 프로그래밍 규칙은 C++을 구성하는 어느 하위 언어를 주로 사용하느냐에 따라 달라질 수 있으니, 필요한 부분에 맞게 전략적으로 규칙을 적용시켜야 한다.


<br><br><br>

<a name="Item2"></a>
## 2. #define보다는 const, enum, inline.

가급적이면 선행 처리자보다 컴파일러를 더 가까이 하는 것이 좋다.

#define 매크로를 사용할 때, 우리의 눈에는 기호식 이름(symbolic name)이 보이지만, 컴파일러는 기호식 이름을 지우고 상수로 바꿔버린다. 그래서 만약 해당 매크로를 통해 에러가 난다면 혼동의 여지가 있다. 이는 기호식 디버거(symbolic debugger)나 기호 테이블에도 마찬가지로 발생할 수 있는 문제이다.

이런 문제는 매크로 대신 const 상수를 사용하면 해결된다. const 상수는 컴파일러에서도 인식 가능하며 기호 테이블에도 들어간다.

그리고 #define을 썼을 때에는 선행 처리자에 의해 사용 횟수만큼 상수의 사본이 들어가지만, const 상수를 이용시에는 사본은 하나만 생기기 때문에 컴파일 후의 최종 코드 크기가 더 작게 나올 수 있다.

#define을 상수로 교체할 때는 두 가지 경우를 주의해야 하는데, 상수 포인터