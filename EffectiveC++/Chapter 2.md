[뒤로](https://github.com/papamoomin/Study#a-tour-of-c)  

# 목차
[5. C++이 사용자 모르게 만들어 호출하는 함수에 주의하자.](#Item5)<br>
[6. 컴파일러가 만든 함수가 필요가 없다면 사용을 막아버려라.](#Item6)<br>
[7. 다형성을 가진 기본 클래스는 반드시 가상 소멸자를 선언하라.](#Item7)<br>
[8. 예외가 소멸자를 벗어나지 못하게 하라.](#Item8)<br>


<br><br><br>

# Chapter 2. 생성자, 소멸자, 대입 연산자

- 생성자 : 새로운 객체를 메모리에 만들 때 필요한 과정을 제어하고 객체의 초기화를 맡는 함수
- 소멸자 : 객체를 없앰과 동시에 객체가 메모리에서 적절히 사라질 수 있도록 제어하는 함수
- 대입 연산자 : 기존의 객체에 다른 객체의 값을 줄 때 사용하는 함수

<a name="Item5"></a>
## 5. C++이 사용자 모르게 만들어 호출하는 함수에 주의하자.

빈 클래스처럼 아무 것도 선언하지 않은 것처럼 보여도 컴파일러가 필요할 때 알아서 선언해주는 함수들이 있다.  
기본형 함수들인 복사 생성자, 복사 대입 연산자, 소멸자 함수들인데, 이들은 모두 public이며 inline이다.

이 말인즉슨,

```cpp
class Empty{};
```

라고 작성하였더라도 실질적으로는

```cpp
class Empty
{
public:	Empty() {};									//기본 생성자
public:	Empty(const Empty& rhs) {};					//복사 생성자
public:	~Empty() {};								//소멸자
public:	Empty&	operator=(const Empty& rhs) {};		//복사 대입 연산자
};
```

이런 코드인 셈이나 다름이 없다는 의미이다.

그리고 이런 코드들이 나타나는 조건은 다음과 같다.
```cpp
Empty x;	//기본 생성자와 소멸자
Empty y(x);	//복사 생성자
x = y;		//복사 대입 연산자
```

<br>

기본 생성자와 소멸자는 컴파일러에게 기본 클래스 및 비정적 데이터 멤버들의 생성자와 소멸자를 호출할 수 있는 자리를 마련해준다. 그리고 이 때 소멸자는 부모 클래스의 소멸자가 가상 소멸자가 아니라면 비가상 소멸자로 만들어진다는 점을 명심하자.

그리고 만약 생성자를 명시적으로 선언하였다면 기본 생성자는 만들어지지 않음을 기억하여야 한다.

<br>

복사 생성자와 복사 대입 연산자는 원본 객체의 비정적 데이터를 사본 객체로 복사해주는 역할을 한다.

```cpp
class A
{
public:		A(const char* name, const int num);

private:	std::string _name;
private:	int	_num;
};

int main()
{
	A x("messi", 10);
	A y(x);				//여기서 복사 생성자가 호출된다.

	return 0;
}
```

여기서 string은 자체 복사 생성자를 가지고 있으므로, x의 _name은 string의 복사 생성자의 인자가 된다. 그리고 _num의 경우는 기본 타입이므로 비트를 그대로 복사하는 식으로 진행될 것이다.

<br>

컴파일러가 만드는 복사 대입 연산자는 적법해야(legal)하고 이치에 맞아야(reasonable) 한다. 그렇지 않다면 컴파일러는 operator=의 자동생성을 거부해버린다.

```cpp
class A
{
public: 	A(std::string& name, const int num);	//name이 참조자가 되어 
													//상수타입의 name을 넣지 못한다.

private:	std::string&	_name;	//참조자
private:	const int		_num;	//상수
};

int main()
{
	std::string a("aaa");
	std::string b("bbb");

	A x(a, 1);
	A y(b, 2);
	x = y;		//대입 연산. 컴파일 에러.
	return 0;
}
```
x, y는 모두 참조자이며, 이런 경우 참조자 자체가 바뀌어야 할지, 아니면 y의 _name을 참조해야 할지가 애매해진다. 이런 경우에 컴파일러는 컴파일 에러를 출력. 

참조자나 상수 객체를 데이터 멤버로 가지려면 직접 복사 대입 연산자를 만들어야 함을 주의하라.

그리고 private으로 복사 대입 연산자를 선언하는 경우에는 암시적 복사 생성자를 가질 수 없으며, 파생 클래스라 할지라도 호출할 권한이 없어진다는 점도 명심하여야 할 것.

<br>

정리하자면 컴파일러는 경우에 따라 클래스에 대해 기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자를 암시적으로 만들 수 있다.


<br><br><br>


<a name="Item6"></a>
## 6. 컴파일러가 만든 함수가 필요가 없다면 사용을 막아버려라.

컴파일러는 5번 항목에서 말했듯이, 만들지 않아도 알아서 함수를 만들어버리곤 한다. 그런데 만약 복사를 막고 싶다면 어떻게 해야할까?

컴파일러가 만드는 함수는 public으로 선언되므로, 명시적으로 private에 해당 함수들을 선언해주면 해결된다. 즉, 복사의 경우는 외부에서의 호출이 필요하므로 private으로 처리하여 외부 호출을 막아버릴 수 있다.

하지만 만약 friend를 이용하여 private을 호출해버린다면? 그걸 막기 위해 private으로 선언 후 구현하지 않는 방식을 사용한다. iostream 라이브러리의 ios_base, basic_ios, sentry 등에도 사용되는 기법이다.

이를 적용하면 다음과 같은 코드가 된다.

```cpp
class object 
{
	public:		object();

	private:	object(const object&);				//선언만 해둔다.
	private:	object& operator=(const object&);	//선언만 해둔다.
};

int main()
{
	object a;
	object b(a);	//복사 불가
	object b = a;	//복사 불가
	return 0;
}
```
이렇게 한다면 컴파일 에러가 날 것이고, 멥버 함수나 프렌드 함수 내에서 할 경우 링크 에러가 난다.

그리고 링크 에러가 발생하는 시점을 컴파일 시점으로 옮길 수 있는데ㅡ에러는 미리 탐지하는 것이 좋으므로 권장하는 바라고 함ㅡ, 복사 생성자와 복사 대입 연산자를 private으로 하되, 이걸 별도의 기본 클래스에 넣은 뒤 원래 사용하려던 클래스에서 파생을 시키는 것이다. 그렇게 하면 별도의 기본 클래스는 복사 방지만 맡게 된다.

```cpp
class noncopyable
{
protected:	noncopyable() {};		//파생 클래스에게 생성 허용
protected:	~noncopyable() {};		//파생 클래스에게 소멸 허용

private:	noncopyable(const noncopyable&);			//복사 방지
private:	noncopyable& operator=(const noncopyable&);	//복사 방지
};

class object : private noncopyable
{
	//복사 생성자와 복사 대입 연산자는 선언되지 않는다.
};
```

컴파일러가 생성한 복사 함수는 기본 클래스의 대응 버전을 호출하게 되어있으나, 기본 클래스에서 비공개로 되어있기에 호출할 수가 없다.

그리고 여기 noncopyable의 구현에 대해 기술하겠다.
1. noncopyable로부터의 상속은 public이 아니어도 된다.
2. noncopyable의 소멸자는 가상 소멸자가 아니어도 된다.
3. noncopyable은 공백 기본 클래스 최적화 기법을 사용할 수도 있으나, 기본 클래스인 탓에 다중 상속이 된다면 의도한 기법대로 동작하지 않을 가능성이 있다.
4. 부스트 라이브러리에 해당 항목과 같은 클래스가 있는데, 사용해도 된다. (이름은 noncopyable 그대로이다.)

<br>

정리하자면 컴파일러에서 자동으로 선언해주는 함수를 막으려면 대응되는 함수를 private으로 선언 후 구현을 하지 말거나, noncopyable과 같은 기본 클래스를 이용하라.


<br><br><br>


<a name="Item7"></a>
## 7. 다형성을 가진 기본 클래스는 반드시 가상 소멸자를 선언하라.

```cpp
class foodMaker
{
	public:		foodMaker();
	public:		~foodMaker();
};

class koreanFoodMaker : public foodMaker {};
class AmericanFoodMaker : public foodMaker {};
```

파생 클래스를 사용하는 사용자는 정보에 접근하기 위해 기본 클래스의 포인터를 반환하는 함수를 이용하곤 한다. (여기서 파생 클래스 객체에 대한 기본 클래스 포인터를 반환하는 함수를 팩토리 함수라고 부른다.)

```cpp
foodMaker*	getFoodMaker();	//파생 클래스에서 동적으로 할당된 객체의 포인터 반환 용도
```

팩토리 함수의 규약대로라면 getFoodMaker로 반환되는 객체는 힙 메모리에 있으므로 메모리 릭을 막기 위해 delete 해줘야 한다.

```cpp
foorMaker* hungry = getFoodMaker();

delete hungry;
```

허나 객체 삭제를 사용자에게만 전가시키는 것은 에러 발생 확률을 높이는 것과 다르지 않다.

여기서 문제는 getFoodMaker 함수가 반환하는 포인터는 파생 클래스를 통해 삭제되며, 기본 클래스인 foodMaker의 소멸자가 비가상 소멸자이기에 파생 클래스가 소멸되지 않게 된다는 점이다.

getFoodMaker를 통해 얻은 koreanFoodMaker 객체를 예로 들어보자. 이 객체가 기본 클래스 포인터를 통해 삭제될 때, 파생 클래스의 소멸자는 불리지 않는다. 즉, 기본 클래스에 있지 않은, 파생 클래스만 가진 부분은 소멸되지 않고 남아있게 되는 것이다. 이를 부분 소멸(partially destroyed) 객체라고 부른다.

이를 막는 방법은 간단하다. 기본 클래스의 소멸자는 모두 가상 소멸자로 두어라.

```cpp
class foodMaker
{
	public:		foodMaker();
	public:		virtual ~foodMaker();
};

class koreanFoodMaker : public foodMaker {};
class AmericanFoodMaker : public foodMaker {};
```

이렇게 한다면 이제 객체 소멸 시 파생 클래스만 가진 부분도 모두 잘 소멸된다.

기본 클래스라면, 그리고 가상 함수를 가진 함수라면 가상 소멸자를 가져야 한다.

<br>

여기서 반대로, 파생 클래스를 가질 생각이 없는 클래스의 소멸자를 가상 소멸자로 두는 것은 좋지 않다.

가상 함수를 가진 클래스는 프로그램 실행 중 주어진 객체에 대해 어떤 가상 함수를 호출할 지를 결정하기 위한 정보를 포인터의 형태로 저장하는 자료구조를 가진다. 여기서 해당 포인터를 vptr(virtual table pointer = 가상 함수 테이블 포인터)라고 부르며, 포인터가 저장된 배열을 vtbl(virtual table = 가상 함수 테이블)이라고 부른다.

즉, 파생 클래스를 가질 필요가 없는데 virtual 함수를 가진다면 해당 클래스를 가진 객체의 크기가 커진다는 것이다. 거기다가 이식성, 다른 언어와의 호환성이 사라진다. 다른 언어와 데이터 구조를 맞췄다고 하더라도 vptr은 어찌 할 방도가 없는 까닭이다.

<br>

그리고 가상 함수가 없음에 불구하고 비가상 소멸자로 문제가 발생할 수도 있다.

std::string은 가상 함수가 없지만, 가끔가다 std::string을 기본 클래스로 하여 파생 클래스를 만드는 미친 행각이 목격되곤 한다. 이런 경우 파생 클래스의 포인터를 기본 클래스의 포인터로 변환한 후 delete가 되는 순간 파생 클래스의 소멸자가 호출되지 않는 문제가 생긴다.

어떤 클래스든 상속을 받으려면 그 클래스가 가상 소멸자를 가지고 있는지부터 확인하자.

<br>

순수 가상 함수를 이용해 순수 가상 소멸자를 두는 것도 좋은 방법이다.

순수 가상 함수는 해당 클래스를 추상 클래스(abstract class)ㅡ자체 타입으로는 객체를 생성할 수 없는 클래스ㅡ로 만들어 준다.

여기서 주의할 점이 있다. 소멸자가 동작하는 순서는 가장 말단의 파생 클래스부터 호출하여 거슬러 올라가는 방식인데, 컴파일러는 기본 클래스의 소멸자를 호출하기 위해 파생 클래스의 소멸자를 사용할 것이므로 순수 가상 소멸자의 정의를 만들어두지 않으면 링크 에러가 발생한다.

```cpp
class A
{
public:	virtual ~A() = 0;
};

A::~A()
{
	//순수 가상 소멸자의 정의
}
```

이렇듯 기본 클래스의 손에 가상 소멸자를 두는 규칙은 다형성을 가진 기본 클래스에 한정된다. 기본 클래스의 인터페이스를 통해 파생 클래스의 조작을 허용하도록 설계한 클래스에 한하여만 적용된다는 것이다.

모든 클래스가 다형성을 갖도록 설계되진 않으므로, 가상 소멸자는 다형성의 유무를 판단하여 사용하도록 하여야 한다.

<br>

정리하자면, 다형성을 가진 기본 클래스라면. 즉, 가상 함수를 하나라도 가지고 있다면 가상 소멸자를 불러줘야 한다. 그리고 이런 경우가 아니라면 가상 소멸자를 절대 부르지 말아야 한다.


<br><br><br>

<a name="Item8"></a>
## 8. 예외가 소멸자를 벗어나지 못하게 하라.

```cpp
class A
{
public:		~A() {};	//여기서 예외가 발생한다 가정.
};

int main()
{
	std::vector<A> aVec;
	return 0;
}	//aVec은 여기서 소멸
```