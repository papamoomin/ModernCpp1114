# 목차
[1. 소개](#1.-소개)  
[2. 프로그램](#2.-프로그램)  
[3. 함수](#3.-함수)  
[4. 타입과 변수, 산술 연산](#4.-타입과-변수,-산술-연산)  


<br><br><br>

# 1. 소개

## 해당 장에서 살펴볼 것
1. C++의 표기법
2. C++의 메모리 모델과 계산 모델
3. 코드를 조직화해 프로그램을 만드는 방법
4. 절차적 프로그래밍 (Procedural Programming)

<br><br><br>

# 2. 프로그램
 - C++은 컴파일되는 언어이다.  
프로그램을 실행하려면 <b>컴파일러</b>가 각 소스 파일을 처리해 <b>목적 파일</b>(Object File)들을 만들고, 그 <b>목적 파일</b>들을 <b>링커</b>(Linker)가 병합해 <b>실행 파일</b>로 만든다.  

 - C++로 짜인 실행 파일은 시스템과 하드웨어의 조합에 맞게 만들어지므로 <b>이식성</b><sup id="up1">[[1]](#down1)</sup>이 없다.  
<b>C++ 프로그램의 이식성</b>에 논의할 때는 주로 <b>소스코드의 이식성</b>을 뜻한다. 즉, 소스코드를 여러 시스템에서 컴파일, 실행하는 것은 문제가 없다.  

<br><br><br>

## ISO C++의 두 가지 요소

<b>ISO</b> : International Organization for Standardization. <b>국제 표준화 기구</b>.  
즉, <b>ISO C++</b>은 <b>표준 C++</b>을 뜻한다.  

ISO C++의 두 요소
  - <b>내장 타입</b>(built-in type : char, int 등)과 <b>루프</b>(loop : for, while 등)를 비롯한 <b>핵심 언어 기능</b>(Core language features)

  - <b>컨테이너</b>(container : vector, map 등)와 <b>I/O 연산</b>(<<, getline() 등)을 비롯한 <b>표준 라이브러리 구성 요소</b>(Standard library components)

<b>표준 라이브러리 구성 요소는</b> '스레드 컨텍스트 스위칭<sup id="up2">[[2]](#down2)</sup>' 등을 위한 보조적인 머신 코드만 제외하면, 모든 C++ 구현체에서 제공하는 <b>일반적인 C++ 코드만으로도 구현이 가능하다.</b>  
이렇듯 C++은 충분한 표현력을 지니며, 대부분의 시스템 프로그래밍 작업에 효과적이다.  

C++은 <b>정적 타입 언어</b>(Statically typed language)이다.  
이는 <b>컴파일러</b>가 모든 구성 요소(객체, 값, 이름, 표현식 등)를 사용하는 곳에서 그 타입을 알 수 있어야 한다는 뜻이다.  
객체의 타입을 바탕으로 그 객체에 적용할 연산의 집합이 정해진다.

<br><br><br>

## Hello, World!

```c++
int main()
{ 
    // 최소한의 C++ 프로그램
}
```
 - 이 코드는 아무런 <b>인자</b>(arguments)도 전달받지 않고 아무 일도 하지 않는 <b>main()</b>이라는 <b>함수</b>(function)를 정의한다.  

 - 중괄호 <b>{ }</b>는 <b>그룹핑</b>을 의미하는데, 위 코드에서는 <b>함수 몸체(body)의 시작과 끝</b>을 가리킨다.  

 - 이중 슬래시 <b>//</b>는 줄 끝까지 이어지는 <b>주석(comment)의 시작</b>을 나타낸다. 주석은 사람이 읽기 위한 것이며, <b>컴파일러는 주석을 무시</b>한다.  

 - 모든 C++ 프로그램은 전역 함수인 <b>main()</b>을 오직 하나 포함한다. <b>main()은 프로그램의 시작</b>이며, int 값을 반환한다.  
 반환 값이 존재하지 않는 경우 프로그램의 올바른 완료를 나타내는 값이 시스템에 전달된다.  
 <b>main()</b>이 <b>0을 반환하면 프로그램의 올바른 종료, 0이 아닌 값은 프로그램의 실패</b>를 뜻한다.  
 단, 윈도우 기반에서는 이 반환 값을 사용하지 않으나 리눅스나 유닉스 기반 환경에서는 반환 값을 사용함을 유의해야 한다.  

<br>

```C++
#include<iostream>
int main()
{
    std::cout << "Hello, World!\n";
}
```
 - 이 코드는 `Hello, World!`를 출력한다.  

 - <b>#include &lt;iostream&gt;</b>은 <b>iostream</b><sup id="up3">[[3]](#down3)</sup>에 존재하는 표준 스트림<sup id="up4">[[4]](#down4)</sup> 입출력 기능의 선언(declaration)을 포함(include)하도록 컴파일러에 지시한다.

 - <b>std::cout << "Hello, World!\n";</b>은 위에 선언한 iostream에 <b>std라는 표준 라이브러리 네임스페이스<sup id="up5">[[5]](#down5)</sup>(namespace)</b> 안에 있는 cout을 이용해 출력을 하는 줄이다.  

 - 연산자 <b><<</b>는 <b>두 번째 인자를 첫 번째 인자에 써넣는다</b>라는 뜻을 가지고 있다. 여기서는 문자열 리터럴<sup id="up6">[[6]](#down6)</sup> <b>"Hello, World!\n"</b>를 표준 출력 스트림인 <b>std::cout</b>에 쓴다는 의미이다.

- <b>\n</b>는 <b>개행 문자</b>로, 문자열에서 백슬래시는 다른 문자와 결합해 특수 문자로 쓰인다.  

- 실행 가능한 모든 코드는 기본적으로 함수 안에 위치하며, 위 코드와 같이 <b>main()</b>으로부터 직/간접적으로 호출된다.  

<br>

```C++
#include <iostream>
using namespace std;
double Square(double a)
{
    return a*a;
}

void PrintSquare(double a)
{
    cout << "the square of " << a << " is " << Square(a) << "\n";
}

int main()
{
    PrintSquare(1.234);
}
```
- 위 코드의 실행 결과는 `the square of 1.234 is 1.52276` 이다.

- <b>using namespace std;</b>는 std::를 지정하지 않고도 std의 이름을 볼 수 있게 한다.

- 함수 이름 앞에 붙는 것은 <b>리턴 타입</b>으로, int는 int 형을, double은 double 형을 리턴한다는 의미이며 void는 해당 함수가 아무 값도 반환하지 않는다는 의미이다.

<br><br><br>

# 3. 함수

C++에서는 무언가를 수행할 때 주로 <b>함수</b>를 호출하여 작업을 수행한다.  
<b>함수의 정의</b>에는 그 작업을 어떻게 수행하는지 명시되어 있으며, <b>함수를 호출</b>하기 위해서는 그 전에 <b>함수를 선언</b>해두어야 한다.  
함수 선언에는 <b>함수의 이름</b>과 반환할 <b>리턴 타입</b>, 호출 시 주어지는 <b>인자의 수와 타입</b>을 명시한다.  
<br>
```C++
int* NextNum();
void Exit(int);
double Sqrt(double);
```
 - 함수 선언은 함수의 <b>이름 앞에 리턴 타입</b>이, <b>이름 뒤 괄호 안에는 인자의 타입</b>이 주어진다.

 - <b>int* NextNum();</b>은 인자는 없으나, int를 가리키는 포인터(int*)를 리턴한다.

 - <b>void Exit(int);</b>는 int를 인자로 받고, 아무 것도 리턴하지 않는다.

 - <b>double Sqrt(double);</b>는 double을 인자로 받고, double을 리턴한다.


```C++
double s2 = Sqrt(2);
double s3 = Sqrt("two"); // ERROR!
```
 - <b>Sqrt(2)</b>에서는 2가 double로 암묵적 형변환을 거친 후 호출된다.

 - <b>Sqrt("two");</b>에서는 문자열이 double로 형변환될 수 없으므로 에러가 난다.


```C++
double Sqrt(double d);
double Square(double);
```
 - <b>함수 선언은 인자의 이름을 포함</b>할 수 있다. 이는 가독성에 도움을 준다.

 - 함수의 선언과 정의를 한 번에 하는 경우가 아니라면, <b>컴파일러는 인자의 이름을 무시</b>한다.


```C++
double Get(const vector<double>&vec, int index);
```
 - <b>함수의 타입</b>은 <b>리턴 값의 타입</b>과 <b>인자의 타입</b>으로 이뤄진다.

 - 위 예시의 함수 타입은 double(const vector<double>&, int) 이다.

```C++
char& String::operator[](int index);
```
 - 위 예시의 함수 타입은 char& String::(int) 이다.
 - 이처럼 <b>클래스의 멤버 함수의 타입은 클래스의 이름을 포함</b>한다.

<br><br>

작성한 코드가 이해하기 쉽게 하는 것은 유지 보수의 용이성을 높이는 첫 걸음이다.  
그리고 이해하기 쉬운 코드를 만드는 첫 걸음은 작업을 의미 있는 단위(함수, 클래스로 표현되는)로 나누고, 그 단위에 적절한 이름을 붙이는 것이다.  
이렇게 하면 함수가 작업 수행의 기본적인 용어집 역할을 한다. 가장 훌륭한 예시는 C++ 표준 알고리즘(itoa, sort 등)을 들 수 있을 것이다.  

코드에 존재하는 에러의 수는 코드의 길이와 복잡도에 비례한다.  
짧은 함수를 많이 사용할수록 이런 문제를 방지할 수 있고, 의존성에 대한 문서화를 강제할 수 있다.  

<br><br>
```C++
void Print(int);
void Print(double);
void Print(string);

void User()
{
    Print(1); // Print(int)
    Print(2.3); // Print(double)
    Print("four"); // Print(string)
}
```
 - 함수의 이름이 같고 인자 타입이 다르면, 컴파일러가 적절한 함수를 선택한다. 이런 식으로 이름이 같으나 인자 타입을 다르게 하는 것을 <b>함수 오버로딩</b>이라고 표현한다. 이는 제네릭 프로그래밍에서 필수적인 부분이며, 이름이 같은 함수들은 같은 의미를 구현하여야 한다.  

```C++
void Print(int, double);
void Print(double, int);

void User()
{
    Print(0,0); // ERROR!
}
```
 - 이처럼 두 함수를 모두 호출할 수 있고, 어느 쪽이 더 적합한지 판단하기 힘든 경우에는 모호한 호출이 되어 컴파일러가 에러를 발생시킨다.

 <br><br><br>

 # 4. 타입과 변수, 산술 연산


<br><br><br><br><br><br><br><br><br><br>
<br><br><br><br><br><br><br><br><br><br>
---
---
<a name="down1">[[1]](#up1)</a>: 원시 프로그램을 다른 기종으로 옮기는 것이 얼마나 용이한가를 나타내는 정도 (출처 : 네이버 지식백과 IT용어사전)  

<a name="down2">[[2]](#up2)</a>: OS는 스레드 하나의 작업을 진행하귀 위해 해당 스레드의 컨텍스트(레지스터, 커널 스택, 사용자 스택 등의 정보들)를 읽어오는데, '스레드 컨텍스트 스위칭'이란 다른 스레드로 작업을 변경할 때 이전 스레드의 컨텍스트를 저장하고 작업을 진행할 스레드의 컨텍스트를 읽어오는 작업을 뜻한다. 즉, 한 스레드에서 다른 스레드로 작업을 넘기는 과정이라 할 수 있다.  

<a name="down3">[[3]](#up3)</a>: Iostream은 C++ 표준 라이브러리에 있는 입출력을 위한 헤더 파일이다. 이름은 Input/Output Stream(입출력 스트림)에서 따왔으며 C언어의 stdio.h와 같은 역할을 한다. (출처 : 위키백과)  

<a name="down4">[[4]](#up4)</a>: Standard Stream. 프로그램에서 입출력으로 주고받는 데이터와 매체를 총칭하는 용어이다. 표준 입력(stdin)과 표준 출력(stdout)(표준 출력과, 표준 에러(stderr)로 나뉨) 분류된다.  
스트림은 프로그램에 드나드는 데이터를 바이트의 흐름으로 표현한 단어이며 유닉스에서 장치를 추상화하여 각 장치를 파일처럼 다루는 것을 해결해, 해당 파일에서 읽히고 나가는 데이터를 스트림이라고 정의했다.  

<a name="down5">[[5]](#up5)</a>: 네임스페이스는 한글로 직역하면 이름공간이라는 뜻인데, 프로그램상에서 하나의 개체를 가리킬 수 있는 범위를 나타내는 공간이다. 한 이름공간은 하나의 이름이 하나의 개체만을 가리키는데, 변수의 이름이 같아도 네임스페이스가 다르면 동명이인마냥 다른 변수로 인식된다.

<a name="down6">[[6]](#up6)</a>: 리터럴은 소스 코드의 고정된 값을 대표하는 용어이다. 상수와 유사한 의미이기에 통상적으로 같은 의미로 쓰이기도 하지만, 엄밀하게 따지면 다르다 할 수 있다.  
상수는 값을 수정할 수 없는 일반 변수라 할 수 있지만, 문자열은 문자나 숫자 등 데이터 그 자체라 볼 수 있다.  
`int a = 1;`에서 a는 변수이고 1은 리터럴이며, `const int b = 2;`에서 b는 상수이고, 2는 리터럴이다.  

