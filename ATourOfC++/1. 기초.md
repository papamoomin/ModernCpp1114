# 목차
[1. 소개](#Chap1)  
[2. 프로그램](#2.-프로그램)  
[3. 함수](#3.-함수)  
[4. 타입과 변수, 산술 연산](#4.-타입과-변수,-산술-연산)  
[5. 스코프와 수명](#5.-스코프와-수명)  
[6. 상수](#6.-상수)  
[7. 포인터, 배열, 참조](#7.-포인터,-배열,-참조)  
[8. 조건 테스트](#8.-조건-테스트)  


<br><br><br>

<a name="Chap1"></a>
# 1. 소개

## 해당 장에서 살펴볼 것
1. C++의 표기법
2. C++의 메모리 모델과 계산 모델
3. 코드를 조직화해 프로그램을 만드는 방법
4. 절차적 프로그래밍 (Procedural Programming)

<br><br><br>

# 2. 프로그램
 - C++은 컴파일되는 언어이다.  
프로그램을 실행하려면 <b>컴파일러</b>가 각 소스 파일을 처리해 <b>목적 파일</b>(Object File)들을 만들고, 그 <b>목적 파일</b>들을 <b>링커</b>(Linker)가 병합해 <b>실행 파일</b>로 만든다.  

 - C++로 짜인 실행 파일은 시스템과 하드웨어의 조합에 맞게 만들어지므로 <b>이식성</b><sup id="up1">[[1]](#down1)</sup>이 없다.  
<b>C++ 프로그램의 이식성</b>에 논의할 때는 주로 <b>소스코드의 이식성</b>을 뜻한다. 즉, 소스코드를 여러 시스템에서 컴파일, 실행하는 것은 문제가 없다.  

<br><br><br>

## ISO C++의 두 가지 요소

<b>ISO</b> : International Organization for Standardization. <b>국제 표준화 기구</b>.  
즉, <b>ISO C++</b>은 <b>표준 C++</b>을 뜻한다.  

ISO C++의 두 요소
  - <b>내장 타입</b>(built-in type : char, int 등)과 <b>루프</b>(loop : for, while 등)를 비롯한 <b>핵심 언어 기능</b>(Core language features)

  - <b>컨테이너</b>(container : vector, map 등)와 <b>I/O 연산</b>(<<, getline() 등)을 비롯한 <b>표준 라이브러리 구성 요소</b>(Standard library components)

<b>표준 라이브러리 구성 요소는</b> '스레드 컨텍스트 스위칭<sup id="up2">[[2]](#down2)</sup>' 등을 위한 보조적인 머신 코드만 제외하면, 모든 C++ 구현체에서 제공하는 <b>일반적인 C++ 코드만으로도 구현이 가능하다.</b>  
이렇듯 C++은 충분한 표현력을 지니며, 대부분의 시스템 프로그래밍 작업에 효과적이다.  

C++은 <b>정적 타입 언어</b>(Statically typed language)이다.  
이는 <b>컴파일러</b>가 모든 구성 요소(객체, 값, 이름, 표현식 등)를 사용하는 곳에서 그 타입을 알 수 있어야 한다는 뜻이다.  
객체의 타입을 바탕으로 그 객체에 적용할 연산의 집합이 정해진다.

<br><br><br>

## Hello, World!

```c++
int main()
{ 
    // 최소한의 C++ 프로그램
}
```
 - 이 코드는 아무런 <b>인자</b>(arguments)도 전달받지 않고 아무 일도 하지 않는 <b>main()</b>이라는 <b>함수</b>(function)를 정의한다.  

 - 중괄호 <b>{ }</b>는 <b>그룹핑</b>을 의미하는데, 위 코드에서는 <b>함수 몸체(body)의 시작과 끝</b>을 가리킨다.  

 - 이중 슬래시 <b>//</b>는 줄 끝까지 이어지는 <b>주석(comment)의 시작</b>을 나타낸다. 주석은 사람이 읽기 위한 것이며, <b>컴파일러는 주석을 무시</b>한다.  

 - 모든 C++ 프로그램은 전역 함수인 <b>main()</b>을 오직 하나 포함한다. <b>main()은 프로그램의 시작</b>이며, int 값을 반환한다.  
 반환 값이 존재하지 않는 경우 프로그램의 올바른 완료를 나타내는 값이 시스템에 전달된다.  
 <b>main()</b>이 <b>0을 반환하면 프로그램의 올바른 종료, 0이 아닌 값은 프로그램의 실패</b>를 뜻한다.  
 단, 윈도우 기반에서는 이 반환 값을 사용하지 않으나 리눅스나 유닉스 기반 환경에서는 반환 값을 사용함을 유의해야 한다.  

<br>

```C++
#include<iostream>
int main()
{
    std::cout << "Hello, World!\n";
}
```
 - 이 코드는 `Hello, World!`를 출력한다.  

 - <b>#include &lt;iostream&gt;</b>은 <b>iostream</b><sup id="up3">[[3]](#down3)</sup>에 존재하는 표준 스트림<sup id="up4">[[4]](#down4)</sup> 입출력 기능의 선언(declaration)을 포함(include)하도록 컴파일러에 지시한다.

 - <b>std::cout << "Hello, World!\n";</b>은 위에 선언한 iostream에 <b>std라는 표준 라이브러리 네임스페이스<sup id="up5">[[5]](#down5)</sup>(namespace)</b> 안에 있는 cout을 이용해 출력을 하는 줄이다.  

 - 연산자 <b><<</b>는 <b>두 번째 인자를 첫 번째 인자에 써넣는다</b>라는 뜻을 가지고 있다. 여기서는 문자열 리터럴<sup id="up6">[[6]](#down6)</sup> <b>"Hello, World!\n"</b>를 표준 출력 스트림인 <b>std::cout</b>에 쓴다는 의미이다.

- <b>\n</b>는 <b>개행 문자</b>로, 문자열에서 백슬래시는 다른 문자와 결합해 특수 문자로 쓰인다.  

- 실행 가능한 모든 코드는 기본적으로 함수 안에 위치하며, 위 코드와 같이 <b>main()</b>으로부터 직/간접적으로 호출된다.  

<br>

```C++
#include <iostream>
using namespace std;
double Square(double a)
{
    return a*a;
}

void PrintSquare(double a)
{
    cout << "the square of " << a << " is " << Square(a) << "\n";
}

int main()
{
    PrintSquare(1.234);
}
```
- 위 코드의 실행 결과는 `the square of 1.234 is 1.52276` 이다.

- <b>using namespace std;</b>는 std::를 지정하지 않고도 std의 이름을 볼 수 있게 한다.

- 함수 이름 앞에 붙는 것은 <b>리턴 타입</b>으로, int는 int 형을, double은 double 형을 리턴한다는 의미이며 void는 해당 함수가 아무 값도 반환하지 않는다는 의미이다.

<br><br><br>

# 3. 함수

C++에서는 무언가를 수행할 때 주로 <b>함수</b>를 호출하여 작업을 수행한다.  
<b>함수의 정의</b>에는 그 작업을 어떻게 수행하는지 명시되어 있으며, <b>함수를 호출</b>하기 위해서는 그 전에 <b>함수를 선언</b>해두어야 한다.  
함수 선언에는 <b>함수의 이름</b>과 반환할 <b>리턴 타입</b>, 호출 시 주어지는 <b>인자의 수와 타입</b>을 명시한다.  
<br>
```C++
int* NextNum();
void Exit(int);
double Sqrt(double);
```
 - 함수 선언은 함수의 <b>이름 앞에 리턴 타입</b>이, <b>이름 뒤 괄호 안에는 인자의 타입</b>이 주어진다.

 - <b>int* NextNum();</b>은 인자는 없으나, int를 가리키는 포인터(int*)를 리턴한다.

 - <b>void Exit(int);</b>는 int를 인자로 받고, 아무 것도 리턴하지 않는다.

 - <b>double Sqrt(double);</b>는 double을 인자로 받고, double을 리턴한다.


```C++
double s2 = Sqrt(2);
double s3 = Sqrt("two"); // ERROR!
```
 - <b>Sqrt(2)</b>에서는 2가 double로 암묵적 형변환을 거친 후 호출된다.

 - <b>Sqrt("two");</b>에서는 문자열이 double로 형변환될 수 없으므로 에러가 난다.


```C++
double Sqrt(double d);
double Square(double);
```
 - <b>함수 선언은 인자의 이름을 포함</b>할 수 있다. 이는 가독성에 도움을 준다.

 - 함수의 선언과 정의를 한 번에 하는 경우가 아니라면, <b>컴파일러는 인자의 이름을 무시</b>한다.


```C++
double Get(const vector<double>&vec, int index);
```
 - <b>함수의 타입</b>은 <b>리턴 값의 타입</b>과 <b>인자의 타입</b>으로 이뤄진다.

 - 위 예시의 함수 타입은 double(const vector<double>&, int) 이다.

```C++
char& String::operator[](int index);
```
 - 위 예시의 함수 타입은 char& String::(int) 이다.
 - 이처럼 <b>클래스의 멤버 함수의 타입은 클래스의 이름을 포함</b>한다.

<br><br>

작성한 코드가 이해하기 쉽게 하는 것은 유지 보수의 용이성을 높이는 첫 걸음이다.  
그리고 이해하기 쉬운 코드를 만드는 첫 걸음은 작업을 의미 있는 단위(함수, 클래스로 표현되는)로 나누고, 그 단위에 적절한 이름을 붙이는 것이다.  
이렇게 하면 함수가 작업 수행의 기본적인 용어집 역할을 한다. 가장 훌륭한 예시는 C++ 표준 알고리즘(itoa, sort 등)을 들 수 있을 것이다.  

코드에 존재하는 에러의 수는 코드의 길이와 복잡도에 비례한다.  
짧은 함수를 많이 사용할수록 이런 문제를 방지할 수 있고, 의존성에 대한 문서화를 강제할 수 있다.  

<br><br>
```C++
void Print(int);
void Print(double);
void Print(string);

void User()
{
    Print(1); // Print(int)
    Print(2.3); // Print(double)
    Print("four"); // Print(string)
}
```
 - 함수의 이름이 같고 인자 타입이 다르면, 컴파일러가 적절한 함수를 선택한다. 이런 식으로 이름이 같으나 인자 타입을 다르게 하는 것을 <b>함수 오버로딩</b>이라고 표현한다. 이는 제네릭 프로그래밍에서 필수적인 부분이며, 이름이 같은 함수들은 같은 의미를 구현하여야 한다.  

```C++
void Print(int, double);
void Print(double, int);

void User()
{
    Print(0,0); // ERROR!
}
```
 - 이처럼 두 함수를 모두 호출할 수 있고, 어느 쪽이 더 적합한지 판단하기 힘든 경우에는 모호한 호출이 되어 컴파일러가 에러를 발생시킨다.

 <br><br><br>

# 4. 타입과 변수, 산술 연산

모든 이름과 표현식에는 수행 가능한 연산을 특정 짓는 타입이 존재한다. 예를 든다면 int는 정수형 변수라는 타입을 나타내는 것이다.  
선언문은 프로그램에 어떠한 실체를 보이는 역할을 하며, 타입을 지정한다.

 - 타입은 객체가 취할 수 있는 값과 연산의 집합을 정의한다.
 - 객체는 어떤 타입의 값을 갖는 메모리다.
 - 값은 타입에 따라 해석되는 비트의 집합이다.
 - 변수는 명명된 객체다.

<br><br>
```C++
bool     // Boolean. true, false.
char     // 문자. 'a', '3', '\n' 등.
int      // 정수. -10, 6, 27984312 등.
double   // 배정도 부동소수점 수. -1.5, 3.14, 6.2e-21 등.
unsigned // 음이 아닌 수. 0, 1, 22391 등. (비트별 논리 연산에 사용되기도 함)
```

 - 기본 타입 중 일부만 보자면 이런 타입들이 있는데, 이런 기본 타입들은 하드웨어의 기능에 직접적으로 상응하며, 저장할 수 있는 값의 스코프를 특정 짓는 고정된 크기를 갖는다.  

 - 모든 타입의 크기는 바이트 단위로 되어있으며, 일반적으로 char 타입은 한 문자를 저장할 수 있는 1바이트의 크기이고 다른 모든 타입들은 그의 배수라 할 수 있다.

 - 타입의 크기는 구현에 따라(머신에 따라) 다르며, sizeof 연산자를 이용해 알 수 있다.

 - 수는 부동소수점 수나 정수로 나뉘며, 소수점(3.14)이나 지수(3e-2)가 있으면 부동소수점 수로 인식된다.

 - 정수 리터럴은 기본적으로 10진수다.

 - 접두사 0b는 2진 정수 리터럴(0b11010010 등), 접두사 0x는 16진 정수 리터럴(0xB4A231D 등), 접두사 0은 8진 정수 리터럴(0324 등)을 의미한다.

 - 긴 리터럴의 가독성을 높이고 싶다면 3.14159'26535'89793 처럼 작은따옴표를 자릿수 구분자로 사용할 수 있다. (값에는 영향을 주지 않는다.)  

<br><br><br>

## 산술 연산

```C++
// 산술 연산자
x+y  // 덧셈
+x   // 단항 덧셈
x-y  // 뺄셈
-x   // 단항 뺄셈
x*y  // 곱셈
x/y  // 나눗셈
x%y  // 정수 나머지 연산

// 비교 연산자
x==y // 같음
x!=y // 같지 않음
x<y  // 보다 작음
x>y  // 보다 큼
x<=y // 보다 작거나 같음
x>=y // 보다 크거나 같음

// 논리 연산자
x&y  // 비트별 곱
x|y  // 비트별 합
x^y  // 비트별 배타적 합
~x   // 비트별 보수
x&&y // 논리곱
x||y // 논리합
!x   // 논리 부정

x+=y // x = x+y
++x  // x = x+1
x-=y // x = x-y
--x  // x = x-1
x*=y // x = x*y
x/=y // x = x/y
x%=y // x = x%y
```

 - 비트별 논리 연산은 비트별로 행해지며, 결과의 타입은 연산 항의 타입과 일치한다.

 - 논리 연산 &&와 ||는 true나 false를 반환한다.

```C++
void SomeFunction()
{
    double d = 1.2; // 부동소수점 수 초기화
    int i = 3;      // 정수 초기화
    d = d+i;        // d = 4.2
    i = d*i;        // i = 12 
                    // d*i는 double 타입으로 연산 결과 12.6이 나오지만
                    // int로 변환하며 소수점을 버림
}
```
 - 표현식에서 수행되는 형변환의 목적은 <b>일반 산술 변환</b>(usual arithmetic conversions)이라고 한다.

 - 표현식은 왼쪽에서 오른쪽으로 평가되며, 예외로 대입만이 오른쪽에서 왼쪽으로 수행된다.

 - 함수 인자를 평가하는 순서는 정해진 바가 없다.

<br><br><br>

## 초기화

객체를 사용하려면 그 전에 객체에 값이 주어져야 하는데, 이를 <b>초기화</b>라고 한다.  
C++은 =나, 중괄호로 묶은 초기값 목록을 이용하는 등의 다양한 초기화 방식을 제공한다.  

```C++
#include <complex>
#include <vector>
using namespace std;
int main()
{
	double d1 = 1.2;
	double d2{ 1.2 };
	double d3 = { 1.2 };
	complex<double> z1 = 1;
	complex<double> z2{ d1, d2 };
	complex<double> z3 = { d1, d2 };
	vector<int> v{ 1,2,3,4,5,6 };
}
```
 - =를 사용한 초기화는 C 언어 시절부터 관례적으로 쓰여왔다. 하지만, <b>{} 목록 형식을 사용하면 정보 누락 위험이 있는 타입 변환으로부터 보호</b>할 수 있다.

 ```C++
int i1 = 1.2;
int i2{ 1.2 }; //ERROR!
 ```
  - i1은 1이 된다. 이처럼 double->int나, int->char 등의 변환을 <b>축소 변환</b>이라고 하며, 정보 누락을 동반하지만 합법적이며 암묵적으로 수행된다. 이 정보 손실은 C언어와의 호환성을 유지하는 댓가다.  

  - {}을 이용하면 축소 변환 시 에러를 일으킨다. 위 i2의 경우에는 부동소수점 수를 정수로 변환하였기 때문에 에러가 발생했다.

```C++
const int a = 3;
const int b; //ERROR!
```
 - 상수는 초기화하지 않은 상태로 존재할 수 없다.

 - 변수 역시, 초기화하지 않는 경우는 극히 드물다. 따라서 적합한 값을 얻기 전까지는 정의하지 말자.

 - 사용자 정의 타입은 암묵적으로 초기화하도록 정의하자.


```C++
double Square(double d)
{
	return d * d;
}
int main()
{
	auto a = true;      // bool
	auto b = 'a';       // char
	auto c = 1;         // int
	auto d = 2.3;       // double
	auto e = Square(d); // Square(double)의 리턴 타입 => double
	auto bb{ true };    // bool
}
```
 - <b>auto를 사용한다면 변수를 선언할 때 초기값으로부터 타입을 유추할 수 있을 시 타입을 명시하지 않아도 된다.</b>

 - auto를 사용할 때 문제를 야기하는 타입 변환의 위험이 없다면 =를 사용할 수 있지만, 원한다면 {}를 사용할 수 있다.

 - auto를 사용하면 중복을 줄임은 물론, 긴 타입명을 작성하는 수고를 덜 수 있다. 특히, 정확한 타입을 알기 어려울 때나 타입명이 긴 제네릭 프로그램에서 특히 유용하다.

 - 구체적인 타입을 언급할 이유가 없는 한 auto를 사용하길 권고한다. 
```
    1. 정의가 속하는 스코프가 크고, 코드를 읽는 사람에게 타입을 명확히 알리고 싶은 경우
    2. 변수의 스코프나 정밀도를 명확히 하고 싶은 경우(float이 아닌 double을 사용하는 등)
```

<br><br><br>

# 5. 스코프와 수명

선언을 하면 이름이 스코프에 드러난다.

1. <b>지역 스코프</b>(local scope) : 함수나 람다(lambda) 안에서 선언된 이름을 <b>지역 이름</b>(local name)이라고 한다. 지역 이름의 유효 스코프는 선언 지점부터 선언이 포함된 블록의 끝까지이다. 함수의 이름도 지역 이름으로 취급한다.

2. <b>클래스 스코프</b>(class scope) : 클래스 정의 내부에 위치하며, 함수나 람다의 밖, enum class 안에서 정의한 이름을 <b>멤버 이름</b>이라고 한다. 이름의 유효 스코프는 해당 이름을 감싸는 선언의 여는 중괄호 { 부터 그 선언의 끝까지이다.

3. <b>네임스페이스 스코프</b>(namespace scope) : 네임스페이스 내부에 위치하고, 함수나 람다, 클래스, enum class의 밖에서 정의한 이름을 <b>네임스페이스 멤버 이름</b>이라고 한다. 이름의 유효 스코프는 선언된 지점부터 네임스페이스 끝까지다.

어떤 구성 요소에도 포함되지 않는 곳에 선언한 이름을 <b>전역 이름</b>(global name)이라고 하며, 전역 네임스페이스에 포함된 것으로 간주한다.

```C++
#include<vector>
using namespace std;

vector<int> v; // 정수형의 전역 벡터

struct Data
{
	string name; // Data의 문자열 멤버
};

void Yeah(string arg) // Yeah는 전역 함수, arg는 정수형 지역 인자
{
	string say{ "Win Win Win" }; // say는 지역
	auto p = new Data{ arg }; // p는 new로 만들어진 Data
}

int main()
{
	Yeah("My Team");
}
```
 - 위처럼 임시 객체나 new로 생성한 객체엔 이름을 붙이지 않는다.

 - 객체는 사용하기 전에 반드시 초기화해야 하며, 포함된 스코프의 끝에서 소멸된다.

 - 네임스페이스 객체의 소멸 시점은 프로그램 종료 시점이다.

 - 멤버의 소멸 시점은 해당 객체를 멤버로 갖는 객체의 소멸 시점에 따라 갈린다.

 - new로 생성한 객체는 delete로 소멸할 때까지 유효하다.

<br><br><br>

# 6. 상수

C++은 두 가지 의미의 <b>불변성</b><sup id="up7">[[7]](#down7)</sup>(immutability)을 지원한다.

1. <b>const</b> : "이 값을 바꾸지 않는다고 약속"한다는 의미. 함수에 포인터나 참조로 전달되는 데이터를 변경하지 않는다고 인터페이스에 명시하고 싶을 때 사용. 컴파일러는 const로 명시된 약속을 지키도록 강제함. 하지만 const의 값은 실행 시간에 계산할 수 있음.

2. <b>constexpr</b> : "이 값을 컴파일 시간에 평가"한다는 의미. 상수 표현식으로만 초기화 가능. 주로 해당 데이터가 파손되는 것을 방지하기 위해 상수로 지정하여 읽기 전용 메모리에 저장하거나, 성능상의 목적을 위해 사용한다. constexpr의 값은 반드시 컴파일 시간에 계산된다.

```C++
constexpr int hund = 100;
void Test(int i)
{
	constexpr int ce1 = hund + 1;   // 컴파일 시간에 hund 값이 확정되어 있음
	constexpr int ce2 = i + 1;      // ERROR! 컴파일 시간에 i 값을 알 수 없음
	constexpr int ce3;              // ERROR! 초기화가 필요함
	const int c1 = hund + 1;        // 이제 이 값은 바꿀 수 없음
	const int c2 = i + 1;           // 이제 이 값은 바꿀 수 없음
	const int c3;                   // ERROR! 초기화가 필요함
}
```
이런 차이라고 볼 수 있다.

```C++
#include<vector>
using namespace std;

double Square(const double &a)            // Square는 인자를 변경하지 않음.
{
	return a * a;
}
int main()
{
	constexpr int a = 1;                // a는 상수
	int b = 2;                          // b는 상수가 아님
	vector<double> c{ 1.2, 3.4, 5.6 };  // c는 상수가 아님
	const double d = Square(b);           // d는 명명된 상수로 실행 시간에 Square(b)를 평가해
                                            // 계산하여 초기화 됨
	constexpr double e = Square(b);       // ERROR! Square(b)는 상수 표현식이 아님.
}
```

 - 만약 컴파일러에 의해 평가되는 상수 표현식 안에서 함수를 사용하려면, 그 함수도 아래 코드처럼 constexpr로 정의하여야 한다.

 ```C++
 constexpr double Square(double a)
{
	return a * a;
}
int main()
{
	int a = 1;
	constexpr double d1 = 3.14*Square(1);   // 3.14*Square(1)은 상수 표현식
	constexpr double d2 = 3.14*Square(a);   // ERROR! a는 상수 표현식이 아니다!
	const double d3 = 3.14*Square(a);       // 실행 시간에 평가 가능
}
```
 - constexpr 함수에 상수가 아닌 인자를 사용하는 경우, 결과는 상수 표현식이 아니게 된다. 즉, 상수 표현식이 요구되지 않는 곳에는 constexpr 함수에 상수가 아닌 표현식을 인자로 써도 된다는 뜻이다. 같은 함수를 상수냐 아니냐로 재정의하지 않아도 된다.


```C++
constexpr double nth(double x, int n)
{
	double a = 1;
	int i = 0;
	while (i < n)
	{
		a *= x;
		++i;
	}
	return a;
}
```
 - constexpr 함수는 내용이 간단하고 부수 효과가 없으며 인자로 전달된 정보만 사용해야 한다. 지역 변수를 정의하거나, 루프를 사용하는 것은 괜찮지만 지역 변수가 아닌 변수는 변경할 수 없다.


constexpr 외에도 배열의 경계나 case의 라벨, 템플릿 값 인자 등은 상수 표현식이 강제된다.  
그 외에 상수 표현식을 사용하는 것은 컴파일 시간 평가가 성능 관점에서 중요한 경우이며, 불변성 역시 중요한 설계 고려 사항이다.

<br><br><br>

# 7. 포인터, 배열, 참조

<b>배열</b>(array)은 연속적인 영역에 할당된 동일한 타입의 시퀀스<sup id="up8">[[8]](#down8)</sup>이며, 가장 기본적인 데이터 컬렉션<sup id="up9">[[9]](#down9)</sup>(collection)이자 하드웨어가 제공하는 기능에 직접적으로 대응한다.

```C++
char a[4];
char *b = &a[2];
char c = *b;
```
 - <b> char a[4];</b>는 문자형 변수 4개를 묶은 배열의 선언이다. 여기서 <b>[]는 배열을 의미</b>한다.

 - <b> char *b = &a[2];</b>는 문자형 포인터 변수 b를 선언하고, 거기에 배열 a의 2번 인덱스(3번째 요소)를 가리키게 한 것이다. 여기서 <b>선언 시의 *는 '~을 가리키는 포인터'</b>를 의미하며 <b>평상시의 &는 주소</b>를 의미한다.

 - <b> char c = *b;</b>는 문자형 변수 c가 포인터 b가 가리키는 주소의 값을 가지게 한 것으로, <b>평상시의 *는 해당 주소의 값</b>을 나타낸다.

```C++
int arr[10]{ 0,1,2,3,4,5,6,7,8,9 };
for (auto i = 0; i < 10; ++i)
	cout << arr[i] << endl;
```
 - 해당 for문은 i를 0에 할당하고, 10보다 작은 동안 1씩 더하며 arr[i]를 출력해주었다. 이 for문은 더 간단하게 바꿔쓸 수 있다.

```C++
int arr[10]{ 0,1,2,3,4,5,6,7,8,9 };
for (auto i : arr)
	cout << i << endl;
```
 - 이렇게 하면 for문은 arr의 모든 요소를 처음부터 끝까지 순회하게 된다. 이런 for문은 어떤 형태의 시퀀스 요소든지 다 사용이 가능하다.

```C++
for (auto i : { 0,1,2,3,4,5,6,7,8,9 })
	cout << i << endl;
```
 - 이렇듯 배열로 정의가 되어있지 않아도 된다. 여기서 기억해야할 것은 해당 방식으로 순회할 경우 배열의 해당 인덱스 값에 바로 접근하는 것이 아니라, 해당 인덱스의 값을 복사해서 사용한다는 점이다.

```C++
int arr[10]{ 0,1,2,3,4,5,6,7,8,9 };
for (auto i : arr)
	cout << ++i << endl;    // 1~10이 출력
for (auto i : arr)
	cout << i << endl;      // 0~9가 출력
```
 - 위에서 ++i를 했지만, 값을 복사해서 사용했기 때문에 실제 arr가 가진 인덱스들의 값은 바뀌지 않았다.

```C++
int arr[10]{ 0,1,2,3,4,5,6,7,8,9 };
for (auto &i : arr)             // 참조 변수 선언
	cout << ++i << endl;    // 1~10이 출력
for (auto i : arr)
	cout << i << endl;      // 1~10이 출력
```
 - 이렇게 곧바로 참조하게 한다면 곧바로 arr가 가진 인덱스 내부의 값을 건드릴 수 있게 된다.

 - 선언 시의 &는 '~을 가리키는 참조'를 의미한다. 참조는 초기화된 후에는 다른 객체를 참조할 수 없다는 점이 포인터 변수와의 차이점이다.

 ```C++
 void Area(vector<int> &v);
 void Area2(const vector<int> &v);
 ```
  - 참조는 함수 인자를 지정할 때 좋다. 참조를 사용하면 함수 호출 시 인자가 복사되지 않으므로 함수 내부에서 접근하는 것이 사본이 아닌 원본임을 보장할 수 있다.

  - 만약 원본을 접근하고 싶으나 변경을 방지하고 싶다면 const를 이용할 수도 있다. 이는 흔하고도 유용하게 사용된다.

<br><br><br>

## 널 포인터

<b>역참조</b><sup id="up10">[[10]](#down10)</sup>(Dereferencing)가 유효함을 보장하려면 포인터는 항상 무언가를 가리켜야 하나, 가리킬 객체가 없거나 가용한 객체가 없을 수 있다. 이런 경우에는 타입을 막론하고 포인터에게 <b>nullptr</b>을 저장한다.  

물론, 포인터가 아닌데 nullptr을 대입하면 에러가 나는 것에 유의하여야 한다.  

```C++
int CountSameChar(const char* str, char c)
{
	if (str == nullptr)
		return 0;

	int count = 0;
	for (; *str != 0; ++str)
		if (*str == c)
			++count;

	return count;
}

int main()
{
	char a[13] = "Hello World!";
	cout << CountSameChar(a, 'o');
}
```
 - 배열의 이름이 곧 0번 인덱스의 포인터가 됨을 이용했으며, str은 0으로 끝나는 C 스타일의 문자열(char 배열)이라 가정한 함수이다.

 - <b>문자열 리터럴에 포함된 문자는 변경이 불가능하므로 인자를 const char*로 선언</b>했다.

 - 예전 코드는 NULL, 0을 사용하였지만 요즘은 <b>정수와 포인터를 혼동할 잠재적 위험을 제거하기 위해 nullptr을 이용</b>한다.

 - '널 참조'라는 것은 없다. <b>참조는 규칙 상 반드시 유효한 객체를 참조하여야하고, 구현체는 이 규칙을 가정한다.</b> 물론, 규칙을 위반할 순 있지만 그렇게 하는 것은 추천하지 않는다.


# 8. 조건 테스트

C++은 선택과 루프를 위한 구문 집합 (if, switch, while, for 등)을 제공한다.  

```C++
bool YesOrNo()
{
	char ans = 0;
	while (1)
	{
		cout << "Yes or No ? (y or n): ";
		cin >> ans;

		if (ans == 'y' || ans == 'Y')
			return true;
		else if (ans == 'n' || ans == 'N')
			return false;
		else
			cout << "Wrong answer!!\n\n";
	}
}
```
 - 출력 연산자 <<에 대응해, <b>입력 연산자 >></b>와 <b>표준 입력 스트림 cin</b>을 사용한 함수이다.

 - <b>if-elseif-else</b> 구문을 사용하였으나, <b>switch-case</b>로 전환할 수도 있다.

 ```C++
 bool YesOrNo()
{
	char ans = 0;
	while (1)
	{
		cout << "Yes or No ? (y or n): ";
		cin >> ans;

		switch (ans)
		{
		case 'y':
		case 'Y': 
			return true;

		case 'n':
		case 'N': 
			return false;

		default:
			cout << "Wrong answer!!\n\n";
		}
	}
}
```
 - Switch 구문은 주어진 값을 상수 집합과 비교하며, 이런 상수들은 <b>case 라벨</b>이라 부른다.

 - case 라벨들은 반드시 서로 달라야하며, 어떤 라벨과도 일치하지 않은 경우에는 <b>default</b>가 선택된다.

 - case를 벗어날 때에는 <b>break</b>문을 사용한다.

```C++
#include<iostream>
#include<vector>
using namespace std;

void SayVectorSize(vector<int> &v)
{
	if (auto n = v.size(); n != 0)
	{
		cout << n << endl;
	}
}

int main()
{
	vector <int> v{ 1,2,3 };
	vector <int> a;
	SayVectorSize(v);
	SayVectorSize(a);
}
```
 - 위와 같은 if문 사용은 C++17에서 도입된 것임을 유의. 별도의 처리를 해주지 않으면 14까지만 지원하는 비주얼 스튜디오에서는 작동하지 않는다. (속성에서 C++17이나 가장 최신버전까지 지원하도록 처리할 수 있음.)

 - if 구문 내에서 정수 n을 정의하고 이어지는 세미콜론 뒤에서 조건을 테스트한다. <b>조건에서 선언한 이름은 if문의 else if나 else 구문 등 다른 브랜치(branch)에서도 유효</b>하다.

 - for 구문처럼 if 구문에서 변수를 선언하는 이유는, <b>변수의 스코프를 제한해 가독성을 향상시키고 에러를 최소화</b>하기 위함이다.

 - 위 코드처럼 0이나 nullptr과 비교하는 경우는 if문을 이렇게까지 생략할 수도 있다.

```C++
if (auto n = v.size())
{
	cout << n << endl;
}
```
 - 이런 경우는 n 자체가 0이나 nullptr이 아닌 경우에 if문 내부로 들어오게 된다.

<br><br><br>

# 9. 하드웨어 대응


<br><br><br><br><br><br><br><br><br><br>
<br><br><br><br><br><br><br><br><br><br>

---
---
<a name="down1">[[1]](#up1)</a>: 원시 프로그램을 다른 기종으로 옮기는 것이 얼마나 용이한가를 나타내는 정도 (출처 : 네이버 지식백과 IT용어사전)  

<a name="down2">[[2]](#up2)</a>: OS는 스레드 하나의 작업을 진행하귀 위해 해당 스레드의 컨텍스트(레지스터, 커널 스택, 사용자 스택 등의 정보들)를 읽어오는데, '스레드 컨텍스트 스위칭'이란 다른 스레드로 작업을 변경할 때 이전 스레드의 컨텍스트를 저장하고 작업을 진행할 스레드의 컨텍스트를 읽어오는 작업을 뜻한다. 즉, 한 스레드에서 다른 스레드로 작업을 넘기는 과정이라 할 수 있다.  

<a name="down3">[[3]](#up3)</a>: Iostream은 C++ 표준 라이브러리에 있는 입출력을 위한 헤더 파일이다. 이름은 Input/Output Stream(입출력 스트림)에서 따왔으며 C언어의 stdio.h와 같은 역할을 한다. (출처 : 위키백과)  

<a name="down4">[[4]](#up4)</a>: Standard Stream. 프로그램에서 입출력으로 주고받는 데이터와 매체를 총칭하는 용어이다. 표준 입력(stdin)과 표준 출력(stdout)(표준 출력과, 표준 에러(stderr)로 나뉨) 분류된다.  
스트림은 프로그램에 드나드는 데이터를 바이트의 흐름으로 표현한 단어이며 유닉스에서 장치를 추상화하여 각 장치를 파일처럼 다루는 것을 해결해, 해당 파일에서 읽히고 나가는 데이터를 스트림이라고 정의했다.  

<a name="down5">[[5]](#up5)</a>: 네임스페이스는 한글로 직역하면 이름공간이라는 뜻인데, 프로그램상에서 하나의 개체를 가리킬 수 있는 범위를 나타내는 공간이다. 한 이름공간은 하나의 이름이 하나의 개체만을 가리키는데, 변수의 이름이 같아도 네임스페이스가 다르면 동명이인마냥 다른 변수로 인식된다.

<a name="down6">[[6]](#up6)</a>: 리터럴은 소스 코드의 고정된 값을 대표하는 용어이다. 상수와 유사한 의미이기에 통상적으로 같은 의미로 쓰이기도 하지만, 엄밀하게 따지면 다르다 할 수 있다.  
상수는 값을 수정할 수 없는 일반 변수라 할 수 있지만, 문자열은 문자나 숫자 등 데이터 그 자체라 볼 수 있다.  
`int a = 1;`에서 a는 변수이고 1은 리터럴이며, `const int b = 2;`에서 b는 상수이고, 2는 리터럴이다.  

<a name="down7">[[7]](#up7)</a>: 불변성이란, 변하지 않는 성질을 뜻한다.  

<a name="down8">[[8]](#up8)</a>: 시퀀스 컨테이너란, 데이터를 선형으로 저장하며 특별한 제약이나 규칙이 정해지지 않은 가장 기본적인 컨테이너이다.

<a name="down9">[[9]](#up9)</a>: 데이터 컬렉션이란, 데이터들의 집합을 뜻한다. 지정된 타입의 데이터들을 한 곳에 묶어둔 것이 바로 데이터 컬렉션이라고 할 수 있다.

<a name="down10">[[10]](#up10)</a>: 역참조란 포인터가 가리키고 있는 주소의 값을 가져오는 것이다. 평상시에 사용하는 *는 역참조 연산자라고 불린다.